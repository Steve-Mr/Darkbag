// Generated by calculate_matrices_pure.py
#ifndef COLOR_MATRICES_H
#define COLOR_MATRICES_H

#include <cstring>

// Row-major 3x3 Matrix
struct Matrix3x3 {
    float data[9];
};

// Helper: Multiply Matrix * Vector
inline void mat_vec_mult(const float m[9], const float in[3], float out[3]) {
    out[0] = m[0]*in[0] + m[1]*in[1] + m[2]*in[2];
    out[1] = m[3]*in[0] + m[4]*in[1] + m[5]*in[2];
    out[2] = m[6]*in[0] + m[7]*in[1] + m[8]*in[2];
}

// Helper: Multiply Matrix * Matrix
inline void mat_mat_mult(const float a[9], const float b[9], float out[9]) {
    float res[9];
    for(int r=0; r<3; r++) {
        for(int c=0; c<3; c++) {
            res[r*3+c] = a[r*3+0]*b[0*3+c] + a[r*3+1]*b[1*3+c] + a[r*3+2]*b[2*3+c];
        }
    }
    memcpy(out, res, 9 * sizeof(float));
}

// Helper: Invert 3x3 Matrix
inline bool mat_inv(const float m[9], float out[9]) {
    float det = m[0]*(m[4]*m[8] - m[5]*m[7]) -
                m[1]*(m[3]*m[8] - m[5]*m[6]) +
                m[2]*(m[3]*m[7] - m[4]*m[6]);

    if (det == 0.0f) return false;
    float invDet = 1.0f / det;

    out[0] = (m[4]*m[8] - m[5]*m[7]) * invDet;
    out[1] = (m[2]*m[7] - m[1]*m[8]) * invDet;
    out[2] = (m[1]*m[5] - m[2]*m[4]) * invDet;

    out[3] = (m[5]*m[6] - m[3]*m[8]) * invDet;
    out[4] = (m[0]*m[8] - m[2]*m[6]) * invDet;
    out[5] = (m[2]*m[3] - m[0]*m[5]) * invDet;

    out[6] = (m[3]*m[7] - m[4]*m[6]) * invDet;
    out[7] = (m[1]*m[6] - m[0]*m[7]) * invDet;
    out[8] = (m[0]*m[4] - m[1]*m[3]) * invDet;

    return true;
}

// Helper: Diagonal Matrix from Vector
inline void mat_diag(const float v[3], float out[9]) {
    memset(out, 0, 9 * sizeof(float));
    out[0] = v[0];
    out[4] = v[1];
    out[8] = v[2];
}

// M_XYZ_D50_to_ProPhoto
static const float M_XYZ_D50_to_ProPhoto[9] = {
    1.34595631f, -0.25560998f, -0.05111226f,
    -0.54459674f, 1.50816141f, 0.02053506f,
    0.00000000f, 0.00000000f, 1.21184464f,
};

// M_ProPhoto_to_AWG
static const float M_ProPhoto_to_AWG[9] = {
    1.22151482f, -0.14075002f, -0.08076481f,
    -0.10800589f, 0.92396685f, 0.18403904f,
    -0.00585063f, 0.04284652f, 0.96300411f,
};

// M_ProPhoto_to_SGamut3
static const float M_ProPhoto_to_SGamut3[9] = {
    1.07231853f, -0.00359589f, -0.06872264f,
    -0.02732668f, 0.90924211f, 0.11808457f,
    0.01317649f, -0.01566753f, 1.00249104f,
};

// M_ProPhoto_to_VGamut
static const float M_ProPhoto_to_VGamut[9] = {
    1.11926363f, -0.04256598f, -0.07669765f,
    -0.02732668f, 0.90924211f, 0.11808457f,
    0.01284764f, -0.00815814f, 0.99531049f,
};

// M_ProPhoto_to_Rec2020
static const float M_ProPhoto_to_Rec2020[9] = {
    1.20061978f, -0.05750041f, -0.14311936f,
    -0.06992636f, 1.08060915f, -0.01068279f,
    0.00553771f, -0.04077827f, 1.03524056f,
};

// M_ProPhoto_to_Rec709
static const float M_ProPhoto_to_Rec709[9] = {
    2.03431391f, -0.72753587f, -0.30677804f,
    -0.22879916f, 1.23171875f, -0.00291959f,
    -0.00856594f, -0.15328333f, 1.16184927f,
};

inline const float* get_prophoto_to_target_matrix(int targetLog) {
    switch (targetLog) {
        case 1: return M_ProPhoto_to_AWG;     // Arri LogC3 -> AWG
        case 2: return M_ProPhoto_to_Rec2020; // F-Log -> Rec.2020
        case 3: return M_ProPhoto_to_Rec2020; // F-Log -> Rec.2020
        case 5: return M_ProPhoto_to_SGamut3; // S-Log3 -> S-Gamut3
        case 6: return M_ProPhoto_to_SGamut3; // S-Log3 -> S-Gamut3
        case 7: return M_ProPhoto_to_VGamut;  // V-Log -> V-Gamut
        case 0: return M_ProPhoto_to_Rec709;  // None -> Rec.709
        default: return M_ProPhoto_to_Rec709; // Default -> Rec.709
    }
}

#endif // COLOR_MATRICES_H
